var _functorTrait, _applyTrait, _setoidTrait, _semigroupTrait, _chainTrait, _ordTrait;

import { equals, pathSatisfies } from 'ramda';

import { isString, isNumber, isFunction } from '../index';
import { isSameType } from './util';
import fl from './mapping';

export var functorTrait = (_functorTrait = {}, _functorTrait[fl.map] = function (fn) {
  return this.constructor[fl.of](fn(this.value));
}, _functorTrait);

export var applyTrait = (_applyTrait = {}, _applyTrait[fl.ap] = function (applyWithFn) {
  var _this = this;

  return applyWithFn.map(function (fn) {
    return fn(_this.value);
  });
}, _applyTrait);

export var setoidTrait = (_setoidTrait = {}, _setoidTrait[fl.equals] = function (setoid) {
  return isSameType(this, setoid) && equals(this.value, setoid.value);
}, _setoidTrait);

export var semigroupTrait = (_semigroupTrait = {}, _semigroupTrait[fl.concat] = function (semigroup) {
  var concatenatedValue = this.value;

  if (isString(this.value) || isNumber(this.value)) {
    concatenatedValue = this.value + semigroup.value;
  } else if (pathSatisfies(isFunction, ['value', fl.concat], this)) {
    concatenatedValue = this.value[fl.concat](semigroup.value);
  } else if (pathSatisfies(isFunction, ['value', 'concat'], this)) {
    concatenatedValue = this.value.concat(semigroup.value);
  }

  return this.constructor[fl.of](concatenatedValue);
}, _semigroupTrait);

export var chainTrait = (_chainTrait = {}, _chainTrait[fl.chain] = function (fn) {
  var newChain = fn(this.value);

  return isSameType(this, newChain) ? newChain : this;
}, _chainTrait);

export var ordTrait = (_ordTrait = {}, _ordTrait[fl.lte] = function (ord) {
  return isSameType(this, ord) && (this.value < ord.value || this[fl.equals](ord));
}, _ordTrait);