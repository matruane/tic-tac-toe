'use strict';

exports.__esModule = true;

var _ramda = /*#__PURE__*/require('ramda');

var _isNotNil = /*#__PURE__*/require('./isNotNil');

var _isNotNil2 = /*#__PURE__*/_interopRequireDefault(_isNotNil);

var _isNonEmptyArray = /*#__PURE__*/require('./isNonEmptyArray');

var _isNonEmptyArray2 = /*#__PURE__*/_interopRequireDefault(_isNonEmptyArray);

var _stubUndefined = /*#__PURE__*/require('./stubUndefined');

var _stubUndefined2 = /*#__PURE__*/_interopRequireDefault(_stubUndefined);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var byArity = /*#__PURE__*/(0, _ramda.comparator)(function (a, b) {
  return a.length > b.length;
});

/**
 * Can be used as a way to compose multiple invokers together to form polymorphic functions,
 * or functions that exhibit different behaviors based on their argument(s).
 * Consumes dispatching functions and keep trying to invoke each in turn, until a non-nil value is returned.
 *
 * Accepts a list of dispatching functions and returns a new function.
 * When invoked, this new function is applied to some arguments,
 * each dispatching function is applied to those same arguments until one of the
 * dispatching functions returns a non-nil value.
 *
 * @func dispatch
 * @memberOf RA
 * @since {@link https://char0n.github.io/ramda-adjunct/2.6.0|v2.6.0}
 * @category Function
 * @sig [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> x1 | x2 | ...
 * @param {!Array} functions A list of functions
 * @return {*|undefined} Returns the first not-nil value, or undefined if either an empty list is provided or none of the dispatching functions returns a non-nil value
 * @see {@link RA.isNotNil}
 * @example
 *
 * // returns first non-nil value
 * const stubNil = () => null;
 * const stubUndefined = () => undefined;
 * const addOne = v => v + 1;
 * const addTwo = v => v + 2;
 *
 * RA.dispatch([stubNil, stubUndefined, addOne, addTwo])(1); //=> 2
 *
 * // acts as a switch
 * const fnSwitch = RA.dispatch([
 *   R.ifElse(RA.isString, s => `${s}-join`, RA.stubUndefined),
 *   R.ifElse(RA.isNumber, n => n + 1, RA.stubUndefined),
 *   R.ifElse(RA.isDate, R.T, RA.stubUndefined),
 * ]);
 * fnSwitch(1); //=> 2
 */


var getMaxArity = /*#__PURE__*/(0, _ramda.pipe)( /*#__PURE__*/(0, _ramda.sort)(byArity), _ramda.head, /*#__PURE__*/(0, _ramda.prop)('length'));

var iteratorFn = /*#__PURE__*/(0, _ramda.curry)(function (args, accumulator, fn) {
  var result = fn.apply(undefined, args);

  return (0, _isNotNil2.default)(result) ? (0, _ramda.reduced)(result) : accumulator;
});

var dispatch = function dispatch(functions) {
  var arity = getMaxArity(functions);

  return (0, _ramda.curryN)(arity, function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (0, _ramda.reduce)(iteratorFn(args), undefined, functions);
  });
};

exports.default = /*#__PURE__*/(0, _ramda.ifElse)(_isNonEmptyArray2.default, dispatch, _stubUndefined2.default);